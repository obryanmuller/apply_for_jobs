Bryan Muller da Silva

AvaliaÃ§Ã£o de conhecimentos em
Desenvolvimento de Software

Sistema Serverless para Compartilhamento Seguro de Senhas

    AVALIAÃ‡ÃƒO TÃ‰CNICA
    â—â€‹ Frontend (produÃ§Ã£o): https://bryansilva.vercel.app/
    â—â€‹ Backend: AWS Lambda + API Gateway + DynamoDB (TTL)
    â—â€‹ Design: Canva(https://www.canva.com)

    1 INTRODUÃ‡ÃƒO
         A soluÃ§Ã£o propÃµe um mecanismo serverless para compartilhamento seguro de

senhas por meio de URL temporÃ¡ria, com controle de expiraÃ§Ã£o temporal e limitaÃ§Ã£o
de visualizaÃ§Ãµes. O sistema foi projetado com foco em seguranÃ§a criptogrÃ¡fica, controle
atÃ´mico de concorrÃªncia e consistÃªncia de experiÃªncia do usuÃ¡rio.

    2. ARQUITETURA
         A soluÃ§Ã£o foi projetada utilizando arquitetura serverless na AWS, eliminando a

necessidade de gerenciamento de infraestrutura e permitindo escalabilidade
automÃ¡tica sob demanda.

    2.1 VISÃƒO GERAL
         O fluxo operacional ocorre da seguinte forma:
             1.â€‹ O usuÃ¡rio acessa o frontend desenvolvido em Next.js, hospedado na
                  Vercel.
             2.â€‹ O frontend consome uma API HTTPS exposta pelo Amazon API Gateway
                  (HTTP API).
             3.â€‹ O API Gateway invoca funÃ§Ãµes AWS Lambda (Python 3.11) responsÃ¡veis
                  pela criaÃ§Ã£o e leitura de segredos.
             4.â€‹ As funÃ§Ãµes interagem com uma tabela no Amazon DynamoDB para
                  persistÃªncia segura.

             5.â€‹ Logs e mÃ©tricas sÃ£o enviados automaticamente ao Amazon CloudWatch.
         Create: Frontend â†’ POST /pwd â†’ Lambda cria token, criptografa e persiste â†’
retorna token para compor URL.
         View: Frontend (/visualizar/{token}) â†’ GET /pwd/{token} â†’ Lambda valida
(tempo/views/revogaÃ§Ã£o), consome 1 view e retorna segredo (se permitido).
    2.2 FIGURA 1 â€“ TOPOLOGIA E SOLUÃ‡ÃƒO SERVERLESS

    â—â€‹ Frontend desacoplado do backend
    â—â€‹ API Gateway como entrypoint
    â—â€‹ Lambda como camada de lÃ³gica
    â—â€‹ DynamoDB com TTL para expiraÃ§Ã£o automÃ¡tica
    2.3 Componentes

         Frontend

             â—â€‹ Next.js (React)
             â—â€‹ Hospedagem: Vercel
             â—â€‹ Deploy contÃ­nuo via push (CI/CD automÃ¡tico)

         API

             â—â€‹ Amazon API Gateway (HTTP API)
             â—â€‹ IntegraÃ§Ã£o direta com Lambda
             â—â€‹ ConfiguraÃ§Ã£o de CORS

         ComputeAWS Lambda (Python 3.11)

             â—â€‹ FunÃ§Ãµes independentes para criaÃ§Ã£o e leitura
             â—â€‹ ExecuÃ§Ã£o stateless

         PersistÃªnciaâ€‹
â€‹ Tabela DynamoDB (modo on-demand):

             â—â€‹ token_hash (Partition Key â€“ String)
             â—â€‹ ciphertext (String)
             â—â€‹ expires_at (Number â€“ TTL)
             â—â€‹ max_views (Number)
             â—â€‹ views_used (Number)
             â—â€‹ revoked (Boolean)

         O token original nÃ£o Ã© armazenado, apenas seu hash criptogrÃ¡fico.

         ExpiraÃ§Ã£o

             â—â€‹ ValidaÃ§Ã£o sÃ­ncrona na Lambda
             â—â€‹ Limpeza automÃ¡tica assÃ­ncrona via DynamoDB TTL

3 FRONTEND (UX, CONSISTÃŠNCIA E REDUÃ‡ÃƒO DE AMBIGUIDADE)
         Uma decisÃ£o no desenvolvimento de frontend foi priorizar a consistÃªncia da
experiÃªncia do usuÃ¡rio, desvinculando-a dos detalhes tÃ©cnicos de implementaÃ§Ã£o. Para
o usuÃ¡rio, a origem da criaÃ§Ã£o da senha (seja no frontend ou no backend) Ã© irrelevante.
O fundamental Ã© que, para o backend, qualquer credencial contida no campo
"sended\_password" Ã© processada como a senha do usuÃ¡rio. Essa abordagem
simplifica as expectativas de comunicaÃ§Ã£o e mitiga a complexidade da lÃ³gica de
processamento.

3.1 UX DEFENSIVA: OCULTAR CUSTOMIZAÃ‡Ã•ES QUANDO NÃƒO FAZEM SENTIDO

         A interface foi projetada para reagir dinamicamente ao estado do campo de
senha.

             â—â€‹ Quando o usuÃ¡rio digita manualmente uma senha, as opÃ§Ãµes de
                  customizaÃ§Ã£o de geraÃ§Ã£o (letras, nÃºmeros, sÃ­mbolos e tamanho) sÃ£o

       í ¼í¾² ocultadas automaticamente, pois deixam de ter efeito funcional.

             â—â€‹ Quando o usuÃ¡rio opta por gerar uma senha pelo Ã­cone de dado ( ), a
                  senha gerada Ã© inserida diretamente no campo de input, passando a ser
                  tratada como senha definida. Nesse momento, as opÃ§Ãµes de
                  customizaÃ§Ã£o tambÃ©m sÃ£o ocultadas, mantendo consistÃªncia de
                  comportamento.

             â—â€‹ Caso o usuÃ¡rio apague o conteÃºdo do input, a interface restaura
                  automaticamente as opÃ§Ãµes de customizaÃ§Ã£o, permitindo uma nova
                  geraÃ§Ã£o configurÃ¡vel.

3.2 TRÃŠS CENÃRIOS SUPORTADOS DE FORMA UNIFORME

         A Figura 1 detalha os trÃªs cenÃ¡rios de criaÃ§Ã£o de senha suportados e o
comportamento resultante do backend.

Tabela 1 - CenÃ¡rios de criaÃ§Ã£o de senha e comportamento do backend.

CenÃ¡rio   AÃ§Ã£o do usuÃ¡rio O que o frontend      Comportamento
                                      envia     do backend

A) Senha  UsuÃ¡rio digita a  Envia               Criptografa e
digitada  senha             sended_password     persiste a senha
                                                    recebida

B) Gerar no  UsuÃ¡rio nÃ£o digita  Gera localmente e  Criptografa e
frontend     e clica no dado     envia como         persiste (igual ao
                                 sended_password    cenÃ¡rio A)

C) Gerar no  UsuÃ¡rio nÃ£o digita, NÃƒO envia          Gera a senha com
backend                                             base na polÃ­tica e
             mas configura       sended_password;   persiste

             polÃ­tica e salva    envia polÃ­tica

         Com isso, o backend permanece simples: ele sÃ³ distingue se existe ou nÃ£o
"sended_password" no payload. Se existe, trata como input final; se nÃ£o existe, aplica
a polÃ­tica de geraÃ§Ã£o e produz o segredo.

    3.3 VALIDAÃ‡Ã•ES E FEEDBACK DE UI

             â—â€‹ Se o usuÃ¡rio tentar gerar senha sem marcar nenhum charset
                  (letras/dÃ­gitos/sÃ­mbolos), a UI apresenta feedback imediato.

             â—â€‹ Campos de expiraÃ§Ã£o e limite de visualizaÃ§Ãµes sÃ£o validados antes do
                  POST (evita criar links invÃ¡lidos).

             â—â€‹ Ao criar, a UI exibe URL pronta para copiar e opÃ§Ã£o de visualizar
                  imediatamente.

             â—â€‹ Na visualizaÃ§Ã£o, o estado de carregamento e erros (404/410) sÃ£o
                  apresentados de forma clara e orientada Ã  aÃ§Ã£o (voltar ao inÃ­cio).

             â—â€‹ ProteÃ§Ã£o contra dupla requisiÃ§Ã£o no React Strict Mode (evita consumir
                  views duas vezes por efeito colateral de render).

    3.4 EDUCAÃ‡ÃƒO CONTEXTUAL: CARD â€œCOMO FUNCIONA?â€

         Para reduzir ambiguidades e evitar interpretaÃ§Ãµes incorretas sobre o
funcionamento do sistema, foi implementado um card explicativo intitulado â€œComo
funciona?â€ diretamente na interface principal.

         Esse componente atua como mecanismo de onboarding leve e contextual,
explicando:
             â—â€‹ Os trÃªs modos possÃ­veis de criaÃ§Ã£o de senha;
             â—â€‹ O comportamento do sistema apÃ³s a criaÃ§Ã£o;
             â—â€‹ As regras de visualizaÃ§Ã£o limitada;
             â—â€‹ O conceito de expiraÃ§Ã£o automÃ¡tica do segredo.
         O objetivo nÃ£o Ã© expor detalhes tÃ©cnicos de implementaÃ§Ã£o, mas sim esclarecer
o fluxo funcional sob a Ã³tica do usuÃ¡rio final.

4 BACKEND (CONTRATO E ATOMICIDADE)

    4.1 POST /PWD â€” CRIAÃ‡ÃƒO DO SEGREDO E TOKEN

         Responsabilidades principais: validar entrada (expiraÃ§Ã£o e limite), gerar token
pÃºblico seguro, calcular hash SHA-256 para armazenamento, criptografar o segredo
com Fernet e persistir no DynamoDB com TTL.

    4.2 GET /PWD/{TOKEN} â€” CONSUMO E REVELAÃ‡ÃƒO CONTROLADA

         A leitura do segredo executa um update condicional atÃ´mico no DynamoDB para
consumir exatamente 1 visualizaÃ§Ã£o somente se o item ainda estiver vÃ¡lido (nÃ£o
expirado, nÃ£o excedeu views). Se o limite for atingido apÃ³s o consumo, o item Ã©
removido imediatamente.

    4.2.1 SÃŠMANTICA HTTP
             â—â€‹ 200 OK: segredo retornado e view consumida.
             â—â€‹ 404 Not Found: token inexistente (nunca criado ou jÃ¡ removido).
             â—â€‹ 410 Gone: expirado por tempo, limite de views excedido ou revogado.

4.3 CONFIGURAÃ‡ÃƒO DE ENDPOINT E VARIÃVEIS DE AMBIENTE
         O backend Ã© exposto publicamente por meio do Amazon API Gateway, sendo

acessado exclusivamente via HTTPS.
O frontend consome a API atravÃ©s da variÃ¡vel de ambiente:

    â—â€‹ NEXT_PUBLIC_API_BASE_URL

Em ambiente de produÃ§Ã£o, essa variÃ¡vel aponta para o endpoint provisionado pelo API
Gateway:

    â—â€‹ https://5y0n5f4ill.execute-api.us-east-1.amazonaws.com

    5 SEGURANÃ‡A

As medidas de seguranÃ§a implementadas foram projetadas para mitigar vazamento de
dados, acesso indevido e condiÃ§Ãµes de corrida (race conditions), garantindo
confidencialidade e integridade do segredo.

    5.1 Confidencialidade do Segredo

             â—â€‹ Criptografia em repouso (Fernet)â€‹
                   O segredo Ã© criptografado antes da persistÃªncia. O DynamoDB nunca
                  armazena dados em plaintext.

             â—â€‹ Hash do token pÃºblico (SHA-256)â€‹
                   O token enviado ao usuÃ¡rio nÃ£o Ã© armazenado diretamente. Apenas seu
                  hash criptogrÃ¡fico Ã© persistido como chave de busca, mitigando exposiÃ§Ã£o
                  caso haja vazamento da base.

             â—â€‹ Transporte seguro (HTTPS)â€‹
                   Todo trÃ¡fego ocorre via TLS atravÃ©s do API Gateway.

5.2 Controle de Acesso e Consumo Seguro

             â—â€‹ Update condicional atÃ´mico (ConditionExpression)â€‹
                   O consumo de visualizaÃ§Ãµes ocorre por meio de operaÃ§Ã£o atÃ´mica no
                  DynamoDB, garantindo que apenas uma requisiÃ§Ã£o consiga consumir
                  cada view vÃ¡lida.

             â—â€‹ Delete imediato ao atingir max_viewsâ€‹
                   ApÃ³s o Ãºltimo consumo permitido, o item Ã© removido imediatamente,
                  mitigando tentativas de replay.

             â—â€‹ ValidaÃ§Ã£o sÃ­ncrona de expiraÃ§Ã£oâ€‹
                   A Lambda valida o tempo de expiraÃ§Ã£o antes da leitura, nÃ£o dependendo
                  exclusivamente do mecanismo assÃ­ncrono de TTL.â€‹
    5.3 ExpiraÃ§Ã£o e MinimizaÃ§Ã£o de SuperfÃ­cie de Ataque

             â—â€‹ DynamoDB TTL (expires_at)â€‹
                   Garante remoÃ§Ã£o automÃ¡tica de registros apÃ³s o prazo definido,
                  reduzindo retenÃ§Ã£o desnecessÃ¡ria de dados sensÃ­veis.

6 MELHORIAS FUTURAS

         Para ambientes de maior criticidade, recomenda-se:

             â—â€‹ Secrets Manager + rotaÃ§Ã£o de chave
             â—â€‹ Alarmes e mÃ©tricas
             â—â€‹ Integrar AWS WAF para mitigaÃ§Ã£o de ataques automatizados

7 CONCLUSÃƒO

         A soluÃ§Ã£o atende aos requisitos do desafio, permitindo ao usuÃ¡rio digitar ou
gerar senhas com base em polÃ­ticas de complexidade, definindo expiraÃ§Ã£o e limite de
visualizaÃ§Ãµes. Ã‰ gerada uma URL Ãºnica para acesso ao segredo, que Ã© removido apÃ³s
o uso ou prazo.

         O desenvolvimento focou na organizaÃ§Ã£o das responsabilidades entre frontend e
backend, mantendo o contrato simples. Foram aplicadas boas prÃ¡ticas de seguranÃ§a
(criptografia do segredo, armazenamento de hash do token pÃºblico e controle atÃ´mico
de visualizaÃ§Ãµes no DynamoDB) e a interface foi pensada para clareza.

         De modo geral, o projeto foi desenvolvido considerando a seguranÃ§a, a
consistÃªncia e a experiÃªncia do usuÃ¡rio.

